<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Stan Development Team" />

<meta name="date" content="2018-09-30" />

<title>Interfacing with External C++ Code</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Interfacing with External C++ Code</h1>
<h4 class="author"><em>Stan Development Team</em></h4>
<h4 class="date"><em>2018-09-30</em></h4>



<p>Starting with the 2.13 release, it is much easier to use external C++ code in a Stan program. This vignette briefly illustrates how to do so.</p>
<p>Suppose that you have (part of) a Stan program that involves Fibonacci numbers, such as</p>
<pre class="stan"><code>functions {
  int fib(int n);
  int fib(int n) {
    if (n &lt;= 0) reject(&quot;n must be positive&quot;);
    return n &lt;= 2 ? 1 : fib(n - 1) + fib(n - 2);
  }
}
model {} // use the fib() function somehow</code></pre>
<p>On the second line, we have <em>declared</em> the <code>fib</code> function before it is <em>defined</em> in order to call it recursively.</p>
<p>For functions that are not recursive, it is not necessary to declare them before defining them but it may be advantageous. For example, I often like to hide the definitions of complicated utility functions that are just a distraction using the <code>#include &quot;file&quot;</code> mechanism</p>
<pre class="stan"><code>functions {
  real complicated(real a, real b, real c, real d, real e, real f, real g);
  #include &quot;complicated.stan&quot; // defines the above function
}
model {} // use the complicated() function somehow</code></pre>
<p>This Stan program would have to be parsed using the <code>stanc_builder</code> function in the <strong>rstan</strong> package rather than the default <code>stanc</code> function (which is called by <code>sampling</code> and <code>stan</code> internally).</p>
<p>Returning to the Fibonacci example, it is not necessary to define the <code>fib</code> function using the Stan language because Stan programs with functions that are <em>declared</em> but not <em>defined</em> can use the standard capabilities of the C++ toolchain to provide the function definitions in C++. For example, this program produces a parser error by default</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">mc &lt;-<span class="st"> </span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="st">'</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="st">functions { int fib(int n); }</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="st">model {} // use the fib() function somehow</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="st">'</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">try</span>(<span class="kw">stan_model</span>(<span class="dt">model_code =</span> mc, <span class="dt">model_name =</span> <span class="st">&quot;parser_error&quot;</span>), <span class="dt">silent =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>## SYNTAX ERROR, MESSAGE(S) FROM PARSER:</code></pre>
<pre><code>## </code></pre>
<pre><code>## Function declared, but not defined. Function name=fib</code></pre>
<pre><code>##   error in 'model18c75f7b9c87_parser_error' at line 2, column 30</code></pre>
<pre><code>##   -------------------------------------------------</code></pre>
<pre><code>##      1:</code></pre>
<pre><code>##      2: functions { int fib(int n); }</code></pre>
<pre><code>##                                      ^</code></pre>
<pre><code>##      3: model {} // use the fib() function somehow</code></pre>
<pre><code>##   -------------------------------------------------</code></pre>
<pre><code>## </code></pre>
<p>However, if we specify the <code>allow_undefined</code> and <code>includes</code> arguments to the <code>stan_model</code> function, and define a <code>fib</code> function in the named C++ header file, then it will parse and compile</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">stan_model</span>(<span class="dt">model_code =</span> mc, <span class="dt">model_name =</span> <span class="st">&quot;external&quot;</span>, <span class="dt">allow_undefined =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">           <span class="dt">includes =</span> <span class="kw">paste0</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">#include &quot;'</span>, </a>
<a class="sourceLine" id="cb15-3" data-line-number="3">                             <span class="kw">file.path</span>(<span class="kw">getwd</span>(), <span class="st">'fib.hpp'</span>), <span class="st">'&quot;</span><span class="ch">\n</span><span class="st">'</span>))</a></code></pre></div>
<p>Specifying the <code>includes</code> argument is a bit awkward because the C++ representation of a Stan program is written and compiled in a temporary directory. Thus, the <code>includes</code> argument must specify a <em>full</em> path to the fib.hpp file, which in this case is in the working directory. Also, the path must be enclosed in double-quotes, which is why single quotes are used in the separate arguments to the <code>paste0</code> function so that double-quotes are interpreted literally. Finally, the <code>includes</code> argument should include newline characters (<code>&quot;\n&quot;</code>) at the start and end. It is possible to specify multiple paths using additional newline characters or include a “meta-header” file that contains <code>#include</code> directives to other C++ header files.</p>
<p>The result of the <code>includes</code> argument is inserted into the C++ file directly after the following lines (as opposed to CmdStan where it is inserted directly <em>before</em> the following lines)</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;stan/model/model_header.hpp&gt;</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">namespace</span> some_namespace {</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">using</span> <span class="bu">std::</span>istream;</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="kw">using</span> <span class="bu">std::</span>string;</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="kw">using</span> <span class="bu">std::</span>stringstream;</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">using</span> <span class="bu">std::</span>vector;</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">using</span> stan::io::dump;</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="kw">using</span> stan::math::lgamma;</a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="kw">using</span> stan::model::prob_grad;</a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="kw">using</span> <span class="kw">namespace</span> stan::math;</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14"><span class="kw">typedef</span> Eigen::Matrix&lt;<span class="dt">double</span>,Eigen::Dynamic,<span class="dv">1</span>&gt; vector_d;</a>
<a class="sourceLine" id="cb16-15" data-line-number="15"><span class="kw">typedef</span> Eigen::Matrix&lt;<span class="dt">double</span>,<span class="dv">1</span>,Eigen::Dynamic&gt; row_vector_d;</a>
<a class="sourceLine" id="cb16-16" data-line-number="16"><span class="kw">typedef</span> Eigen::Matrix&lt;<span class="dt">double</span>,Eigen::Dynamic,Eigen::Dynamic&gt; matrix_d;</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"></a>
<a class="sourceLine" id="cb16-18" data-line-number="18"><span class="at">static</span> <span class="dt">int</span> current_statement_begin__;</a>
<a class="sourceLine" id="cb16-19" data-line-number="19"><span class="co">// various function declarations and / or definitions</span></a></code></pre></div>
<p>Thus, the definition of the <code>fib</code> function in the fib.hpp file need not be enclosed in any particular namespace (which is a random string by default. The “meta-include” stan/model/model_header.hpp file reads as</p>
<pre><code>#ifndef STAN_MODEL_MODEL_HEADER_HPP
#define STAN_MODEL_MODEL_HEADER_HPP

#include &lt;stan/math.hpp&gt;

#include &lt;stan/io/cmd_line.hpp&gt;
#include &lt;stan/io/dump.hpp&gt;
#include &lt;stan/io/program_reader.hpp&gt;
#include &lt;stan/io/reader.hpp&gt;
#include &lt;stan/io/writer.hpp&gt;

#include &lt;stan/lang/rethrow_located.hpp&gt;
#include &lt;stan/model/prob_grad.hpp&gt;
#include &lt;stan/model/indexing.hpp&gt;
#include &lt;stan/services/util/create_rng.hpp&gt;

#include &lt;boost/exception/all.hpp&gt;
#include &lt;boost/random/additive_combine.hpp&gt;
#include &lt;boost/random/linear_congruential.hpp&gt;

#include &lt;cmath&gt;
#include &lt;cstddef&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#endif</code></pre>
<p>so the definition of the <code>fib</code> function in the fib.hpp file could utilize any function in the Stan Math Library (without having to prefix function calls with <code>stan::math::</code>), some typedefs to classes in the Eigen matrix algebra library, plus streams, exceptions, etc. without having to worry about the corresponding header files. Nevertheless, an external C++ file <em>may</em> contain additional include directives that bring in class definitions, for example.</p>
<p>Now let’s examine the fib.hpp file, which contains the C++ lines</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="dt">int</span> fib(<span class="at">const</span> <span class="dt">int</span>&amp;n, <span class="bu">std::</span>ostream* pstream__) {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="cf">if</span> (n &lt;= <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    stringstream errmsg;</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    errmsg &lt;&lt; <span class="st">&quot;n must be positive&quot;</span>;</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="cf">throw</span> <span class="bu">std::</span>domain_error(errmsg.str());</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="cf">return</span> n &lt;= <span class="dv">1</span> ? <span class="dv">1</span> : fib(n - <span class="dv">1</span>, <span class="dv">0</span>) + fib(n - <span class="dv">2</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">}</a></code></pre></div>
<p>This C++ function is essentially what the preceding user-defined function in the Stan language</p>
<pre class="stan"><code>int fib(int n) {
  if (n &lt;= 0) reject(&quot;n must be positive&quot;);
  return n &lt;= 2 ? 1 : fib(n - 1) + fib(n - 2);
}</code></pre>
<p>parses to. Thus, there is no <em>speed</em> advantage to defining the <code>fib</code> function in the external fib.hpp file. However, it is possible to use an external C++ file to handle the gradient of a function analytically as opposed to using Stan’s autodifferentiation capabilities, which are slower and more memory intensive but fully general. In this case, the <code>fib</code> function only deals with integers so there is nothing to take the derivative of. The primary advantage of using an external C++ file is flexibility to do things that cannot be done directly in the Stan language. It is also useful for R packages like <strong>rstanarm</strong> that may want to define some C++ functions in the package’s src directory and rely on the linker to make them available in its Stan programs, which are compiled at (or before) installation time.</p>
<p>In the C++ version, we check if <code>n</code> is non-positive, in which case we throw an exception. It is unnecessary to prefix <code>stringstream</code> with <code>std::</code> because of the <code>using std::stringstream;</code> line in the <em>generated</em> C++ file. However, there is no corresponding <code>using std::domain_error;</code> line, so it has to be qualified appropriately when the exception is thrown.</p>
<p>The only confusing part of the C++ version of the <code>fib</code> function is that it has an additional argument (with no default value) named <code>pstream__</code> that is added to the <em>declaration</em> of the <code>fib</code> function by Stan. Thus, your <em>definition</em> of the <code>fib</code> function needs to match with this signature. This additional argument is a pointer to a <code>std::ostream</code> and is only used if your function prints something to the screen, which is rare. Thus, when we call the <code>fib</code> function recursively in the last line, we specify <code>fib(n - 1, 0) + fib(n - 2, 0);</code> so that the output (if any, and in this case there is none) is directed to the null pointer.</p>
<p>This vignette has employed a toy example with the Fibonacci function, which has little apparent use in a Stan program and if it were useful, would more easily be implemented as a user-defined function in the <code>functions</code> block as illustrated at the outset. The ability to use external C++ code only becomes useful with more complicated C++ functions. It goes without saying that this mechanism ordinarily cannot call functions in C, Fortran, R, or other languages because Stan needs the derivatives with respect to unknown parameters in order to perform estimation. These derivatives are handled with custom C++ types that cannot be processed by functions in other languages that only handle primitive types such as <code>double</code>, <code>float</code>, etc.</p>
<p>That said, it is possible to accomplish a great deal in C++, particularly when utilizing the Stan Math Library. For more details, see <a href="https://arxiv.org/abs/1509.07164">The Stan Math Library: Reverse-Mode Automatic Differentiation in C++</a> and its GitHub <a href="https://github.com/stan-dev/math/">repository</a>. The functions that you <em>declare</em> in the <code>functions</code> block of a Stan program will typically involve templating and type promotion in their signatures when parsed to C++ (the only exceptions are functions whose only arguments are integers, as in the <code>fib</code> function above). Suppose you wanted to define a function whose arguments are real numbers (or at least one of the arguments is). For example,</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">mc &lt;-<span class="st"> </span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="st">'</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="st">functions { real besselK(real v, real z); }</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="st">model {} // use the besselK() function somehow</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="st">'</span></a></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">stan_model</span>(<span class="dt">model_code =</span> mc, <span class="dt">model_name =</span> <span class="st">&quot;external&quot;</span>, <span class="dt">allow_undefined =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">           <span class="dt">includes =</span> <span class="kw">paste0</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">#include &quot;'</span>, </a>
<a class="sourceLine" id="cb21-3" data-line-number="3">                             <span class="kw">file.path</span>(<span class="kw">getwd</span>(), <span class="st">'besselK.hpp'</span>), <span class="st">'&quot;</span><span class="ch">\n</span><span class="st">'</span>))</a></code></pre></div>
<p>Although the Stan Math Library (via Boost) has an implementation of the Modified Bessel Function of the Second Kind, it only supports the case where the order (<code>v</code>) is an integer. The besselK.hpp file reads as</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> T0__, <span class="kw">typename</span> T1__&gt;</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">typename</span> <span class="ex">boost::</span>math<span class="ex">::</span>tools<span class="ex">::</span>promote_args&lt;T0__, T1__&gt;::type</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">besselK(<span class="at">const</span> T0__&amp; v, <span class="at">const</span> T1__&amp; z, <span class="bu">std::</span>ostream* pstream__) {</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="cf">return</span> <span class="ex">boost::</span>math<span class="ex">::</span>cyl_bessel_k(v, z);</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">}</a></code></pre></div>
<p>because, in general, its first two arguments could either be integers, known real numbers, or unknown but real parameters. In the case of unknown real numbers, Stan will need to rely on its autodifferentiation mechanism to keep track of the derivative with respect to those arguments during estimation. But if either of the first two arguments is an integer or a known real number, then Stan avoids taking derivatives with respect to them. Thus, it is useful to utilize C++ templates that can generate all (four in this case) versions of this Bessel function with only a few lines of C++ source code. The first line of besselK.hpp states that the first two arguments are going to be templated with typenames <code>TO__</code> and <code>T1__</code> respectively. The second line is convoluted but merely states that the return type of the <code>besselK</code> function depends on <code>TO__</code> and <code>T1__</code>. In short, if either is an unknown real parameter, then the result will also be an unknown real parameter. The third line contains the generated signature of the function in C++, which involves the typenames <code>TO__</code> and <code>T1__</code>, as well as the pointer to a <code>std::ostream</code> (which is again not used in the body of the function). The body of the <code>besselK</code> function is simply a call to the coresponding function in the Boost Math Library, whose headers are pulled in by the Stan Math Library but the <code>boost::math::</code> prefix is necessary due to the absence of a <code>using boost::math;</code> statement.</p>
<p>An easy way to see what the generated function signature will be is to call the <code>stanc</code> function in the <strong>rstan</strong> package with <code>allow_undefined = TRUE</code> and inspect the resuling C++ code. In this case, I first did</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">try</span>(<span class="kw">readLines</span>(<span class="kw">stanc</span>(<span class="dt">model_code =</span> mc, <span class="dt">allow_undefined =</span> <span class="ot">TRUE</span>)<span class="op">$</span>cppcode))</a></code></pre></div>
<pre><code>## Warning in file(con, &quot;r&quot;): cannot open file '// Code generated by Stan version 2.17.0
## 
## #include &lt;stan/model/model_header.hpp&gt;
## 
## namespace model18c7479879e7_mc_namespace {
## 
## using std::istream;
## using std::string;
## using std::stringstream;
## using std::vector;
## using stan::io::dump;
## using stan::math::lgamma;
## using stan::model::prob_grad;
## using namespace stan::math;
## 
## typedef Eigen::Matrix&lt;double,Eigen::Dynamic,1&gt; vector_d;
## typedef Eigen::Matrix&lt;double,1,Eigen::Dynamic&gt; row_vector_d;
## typedef Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; matrix_d;
## 
## static int current_statement_begin__;
## 
## stan::io::program_reader prog_reader__() {
##     stan::io::program_reader reader;
##     reader.add_event(0, 0, &quot;start&quot;, &quot;model18c7479879e7_mc&quot;);
##     reader.add_event(3, 3, &quot;end&quot;, &quot;model18c7479879e7_mc&quot;);
##     return reader;
## }
## 
## template &lt;typename T0__, typename T1__&gt;
## typename boost::math::tools::promote_args&lt;T0__, T1__&gt;::type
## besselK(const T0__&amp; v,
##             const T1__&amp; z, std::ostream* pstream__);
## 
## class model18c7479879e7_mc : public pro [... truncated]</code></pre>
<p>to see what function signature needed to be written for besselK.hpp.</p>
<p>When using external C++ code, care must be taken to ensure that the function is numerically stable over a wide range of floating point numbers. Indeed, in the case of the <code>besselK</code> function, the derivative with respect to the order argument (<code>v</code>) may not be sufficiently stable numerically. In general, it is best to strip the underlying double-precision numbers out of Stan’s custom scalar types, evaluate the desired function, and then calculate the necessary derivatives analytically in an object whose class that inherits from the <code>vari</code> class in Stan. The details of doing so are beyond the scope of this vignette but are discussed in the links above. Once you go to the trouble of writing such a C++ function, we would welcome a pull request on GitHub to include your C++ function in the Stan Math Library for everyone to benefit from, provided that it can be licensed under the 3-clause BSD license and its use is not overly-specific to your particular Stan program.</p>
<p>The Stan Math Library is compliant with the C++11 standard but currently does not utilize any features that were introduced by the C++11 standard nor does it require a compiler that is compliant with the C++11 standard. However, almost any modern C++ compiler is compliant, so you can use (at least some subset of the) features that were introduced by the C++11 standard in external C++ code and your Stan program should compile (perhaps with some warnings). In particular, you may want to use the <code>auto</code> keyword to avoid having to learn a lot of the messy type-promotion syntax used in the Stan Math Library and the rules for what kind of object is returned by various mathematical operations. For example, under the C++11 standard, the <code>besselK.hpp</code> file could be written as</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> T0__, <span class="kw">typename</span> T1__&gt;</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">auto</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">besselK(<span class="at">const</span> T0__&amp; v, <span class="at">const</span> T1__&amp; z, <span class="bu">std::</span>ostream* pstream__) -&gt; <span class="kw">decltype</span>(v + z) {</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  <span class="cf">return</span> <span class="ex">boost::</span>math<span class="ex">::</span>cyl_bessel_k(v, z);</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">}</a></code></pre></div>
<p>where the <code>auto</code> keyword combined with <code>-&gt; decltype (v + z)</code> results in the same code as the Boost metaprogram <code>typename boost::math::tools::promote_args&lt;T0__, T1__&gt;::type</code>.</p>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
